/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import de.undercouch.gradle.tasks.download.Download
import org.apache.lucene.gradle.plugins.globals.LuceneBuildGlobalsExtension

description = 'Korean Morphological Analyzer'

dependencies {
  moduleApi project(':lucene:core')
  moduleApi project(':lucene:analysis:common')

  moduleTestImplementation project(':lucene:test-framework')
}

//
// This configures regeneration of Nori dictionaries.
//

static void recompileDictionary(Project project, String dictionaryName, Closure closure) {
  project.getExtensions().getByType(LuceneBuildGlobalsExtension).execOps.javaexec {
    mainClass = "org.apache.lucene.analysis.ko.dict.DictionaryBuilder"
    classpath = project.sourceSets.main.runtimeClasspath

    jvmArgs '-Xmx1G'

    with closure
  }
  project.logger.lifecycle("Automaton regenerated from dictionary: ${dictionaryName}")
}

plugins.withType(JavaPlugin).configureEach {
  project.ext {
    targetDir = project.file("src/resources")
  }

  def dictionaryName = "mecab-ko-dic-2.1.1-20180720"
  def dictionarySource = "https://s3.amazonaws.com/lucene-testdata/mecab/${dictionaryName}.tar.gz"
  def compileMecabKo = tasks.register("compileMecabKo", Download, {

    dependsOn sourceSets.main.runtimeClasspath

    def dictionaryFile = file("${buildDir}/generate/${dictionaryName}.tar.gz")
    def unpackedDir = file("${buildDir}/generate/${dictionaryName}")

    src dictionarySource
    dest dictionaryFile
    onlyIfModified true

    doLast {
      buildGlobals.fileOps.delete(sourceSets.main.resources.srcDirs.collect {File location ->
        fileTree(dir: location, include: "org/apache/lucene/analysis/ja/dict/*.dat")
      })

      // Unpack the downloaded archive.
      delete unpackedDir
      ant.untar(src: dictionaryFile, dest: unpackedDir, compression: "gzip") {
        ant.cutdirsmapper(dirs: "1")
      }

      // Compile the dictionary
      recompileDictionary(project, dictionaryName, {
        args += [
          unpackedDir,
          targetDir,
          "utf-8",
          false
        ]
      })
    }
  })

  tasks.register("regenerateDictionariesFromMecabKo", {
    description = "Recompile dictionaries from Mecab-Ko data."

    dependsOn compileMecabKo

    inputs.property("dictionarySource", dictionarySource)
    outputs.files(fileTree(dir: "src/resources/org/apache/lucene/analysis/ko/dict", include: "*.dat"))

    regenerate {
      // No need to run any follow-ups, we generate binary files (not sources).
      followedUpBy = []
      ifSkippedAlsoSkip = ["compileMecabKo"]
    }
  })
}
